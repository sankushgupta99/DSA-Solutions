class Solution {
public:
    int par[301], size[301];
    
    int find(int x){
        if(par[x] == x)
            return x;
        
        int temp = find(par[x]);
        par[x] = temp;
        return temp;
    }
    
    void unionSet(int x, int y){
        int lox = find(x);
        int loy = find(y);
        
        if(size[lox] > size[loy]){
            par[loy] = lox;
            size[lox] += size[loy];
        }
        else{
            par[lox] = loy;
            size[loy] += size[lox];
        }
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        sort(initial.begin(), initial.end());
        for(int i = 0; i < n; i++){
            par[i] = i;
            size[i] = 1;
        }
        
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(graph[i][j] && find(i) != find(j)){
                    unionSet(i, j);
                }
            }
        }
        
        map<int, int> infected_count;
        for(int i : initial){
            int leader = find(i);
            infected_count[leader]++;
        }
        
        int ans = initial[0];
        int max_size = 0;
        for(int i : initial){
            int leader = find(i);
            if(infected_count[leader] == 1 && size[leader] > max_size){
                ans = i;
                max_size = size[leader];
            }
        }
        return ans;
    }
};

//OR

class Solution {
public:
    void DFS(vector<vector<int>>& graph, int src, int visited[], int infected[], int &comp_size, int &inf_count, vector<int> &inf){
        visited[src] = 1;
        comp_size++;
        
        if(infected[src]){
            inf_count++;
            inf.push_back(src);
        }
        
        for(int i = 0; i < graph.size(); i++){
            if(graph[src][i] == 1 && !visited[i]){
                DFS(graph, i, visited, infected, comp_size, inf_count, inf);
            }
        }
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int infected[n];
        memset(infected, 0, sizeof(infected));
        sort(initial.begin(), initial.end());
        
        for(int i : initial){
            infected[i] = 1;
        }
        
        int size[n], infected_count[n], visited[n];
        memset(visited, 0, sizeof(visited));
        memset(size, 0, sizeof(size));
        memset(infected_count, 0, sizeof(infected_count));
        
        for(int i = 0; i < n; i++){
            if(infected[i] && !visited[i]){
                int comp_size = 0, inf_count = 0;
                vector<int> inf;
                
                DFS(graph, i, visited, infected, comp_size, inf_count, inf);
                
                for(int i : inf){
                    size[i] = comp_size;
                    infected_count[i] = inf_count;
                }
            }
        }
        
        int ans = initial[0];
        int max_comp_size_removed = -1;
        for(int i = 0; i < n; i++){
            if(infected[i] && size[i] > max_comp_size_removed && infected_count[i] == 1){
                ans = i;
                max_comp_size_removed = size[i];
            }
        }
        return ans;
    }
};